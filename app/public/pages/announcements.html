<div>
  Announcements

  <br />
  <b>NFT Uploading to IPFS is now live!</b>
  <div class="inner-content announcements" style="background-color: white;">
    <label for="nameInput">Name</label>
    <input type="text" id="nameInput" name="name" /><br />

    <label for="messageInput">Message</label>
    <textarea id="messageInput" cols="30" rows="2" name="message"></textarea><br />

    <label for="passwordInput">Password</label>
    <input id="passwordInput" cols="30" rows="2" name="password"></input><br />

    <label for="pictureInput">Picture</label>
    <input type="file" id="pictureInput" name="picture" multiple /><br />

    <img id="nft_image_preview" class="nft-image-preview"></img><br />

    <button id="nft_ipfs_upload" class="button">Upload to IPFS</button>
    <button id="nft_mint" class="button" disabled="disabled">Mint NFT</button>

  </div>

  <script>
    let photoData = '';
    // demo purposes only
    const codeElem = document.getElementById("code");
    // /demo purposes only

    const fileInput = document.getElementById("pictureInput");

    // This is for storing the base64 strings
    let myFiles = {};
    // if you expect files by default, make this disabled
    // we will wait until the last file being processed
    let isFilesReady = true;

    fileInput.addEventListener("change", async (event) => {
      // clean up earliest items
      myFiles = {};
      // set state of files to false until each of them is processed
      isFilesReady = false;

      // this is to get the input name attribute, in our case it will yield as "picture"
      // I'm doing this because I want you to use this code dynamically
      // so if you change the input name, the result also going to effect
      const inputKey = fileInput.getAttribute("name");
      var files = event.srcElement.files;

      const filePromises = Object.entries(files).map((item) => {
        return new Promise((resolve, reject) => {
          const [index, file] = item;
          const reader = new FileReader();
          reader.readAsBinaryString(file);

          reader.onload = function(event) {
            // if it's multiple upload field then set the object key as picture[0], picture[1]
            // otherwise just use picture
            const fileKey = `${inputKey}${
              files.length > 1 ? `[${index}]` : ""
            }`;
            // Convert Base64 to data URI
            // Assign it to your object
            myFiles[fileKey] = `data:${file.type};base64,${btoa(
              event.target.result
            )}`;

            resolve();
          };
          reader.onerror = function() {
            console.log("can't read the file");
            reject();
          };
        });
      });

      Promise.all(filePromises)
        .then(() => {
          isFilesReady = true;
          photoData = myFiles.picture;
          $('#nft_image_preview').attr('src', photoData);
        })
        .catch((error) => {
          console.log(error);
          console.log("something wrong happened");
        });
    });

    const formElement = document.getElementById("formcarryForm");

    function validateForm() {
      if (photoData != null) {
        return true;
      }
    }

    function submitFormToIPFS() {
      console.log('submitting form');
      let data = {
        name: 'test nameInput',
        description: 'test desc',
        image: photoData
      };
      fetch("https://api.pinata.cloud/pinning/pinJSONToIPFS", {
          method: "POST",
          body: JSON.stringify(data),
          headers: {
            //  "Content-Type": "application/json",
            //  Accept: "application/json"

            // Dev Only, obfuscate when going to prod
            pinata_api_key: "bb8f09c99b53458ffb7b",
            pinata_secret_api_key: "26d0687df99869d7f5642176e545f4455529a2b52e8a1258ee3f32a76a4fbe75"
          }
        })
        .then(function(response) {
          console.log(response);
        })
        .catch(function(error) {
          console.log(error);
        });
    }
    const handleForm = async (event) => {
      event.preventDefault();

      if (!isFilesReady) {
        console.log("files still getting processed");
        return;
      }

      const formData = new FormData(formElement);

      let data = {
        name: formData.get("name"),
        message: formData.get("message")
      };

      Object.entries(myFiles).map((item) => {
        const [key, file] = item;
        // append the file to data object
        data[key] = file;
      });

      codeElem.textContent = JSON.stringify(data, undefined, 2);

      // Click handler for form submission to IPFS
      $("#nft_ipfs_upload").click(function() {
        // Validate form
        validateForm();
        // Submit form data
        submitFormToIPFS();
      });
    };
  </script>
</div>