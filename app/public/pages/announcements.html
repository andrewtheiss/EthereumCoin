<div>
  <br />
  <div class="announcements-title">
    <b>NFT Uploading to IPFS is now live!</b>
  </div>
  <div class="inner-content announcements">
    <label for="nameInput">Name</label>
    <input type="text" id="nameInput" name="name" /><br />

    <label for="descriptionInput">Description</label>
    <textarea id="descriptionInput" cols="30" rows="2" name="message"></textarea><br />

    <label for="passwordInput">Password</label>
    <input id="passwordInput" cols="30" rows="2" name="password"></input><br />

    <label for="pictureInput">Picture</label>
    <input type="file" id="pictureInput" name="picture" multiple /><br />

    <img id="nft_image_preview" class="nft-image-preview"></img><br />

    <button id="nft_ipfs_upload" class="button">Upload to IPFS</button>
    <button id="nft_mint" class="button" disabled="disabled">Mint NFT</button><br />
    <b><a href="" id="ipfs_upload_json_url" target="_blank" class="link-to-ifps-validation"></a></b>
  </div>
  <script>
      let NFTContractABI = false;
      let NFTContractAddress = "0x161A4CfbCEF9954b7020A325E0EAFEebE946995D";
    let dev = false;

    let ipfsUrl = false;

    let photoData = '';
    // demo purposes only
    const codeElem = document.getElementById("code");
    // /demo purposes only

    const fileInput = document.getElementById("pictureInput");

    // This is for storing the base64 strings
    let myFiles = {};
    // if you expect files by default, make this disabled
    // we will wait until the last file being processed
    let isFilesReady = true;

    fileInput.addEventListener("change", async (event) => {
      // clean up earliest items
      myFiles = {};
      // set state of files to false until each of them is processed
      isFilesReady = false;

      // this is to get the input name attribute, in our case it will yield as "picture"
      // I'm doing this because I want you to use this code dynamically
      // so if you change the input name, the result also going to effect
      const inputKey = fileInput.getAttribute("name");
      var files = event.srcElement.files;

      const filePromises = Object.entries(files).map((item) => {
        return new Promise((resolve, reject) => {
          const [index, file] = item;
          const reader = new FileReader();
          reader.readAsBinaryString(file);

          reader.onload = function(event) {
            // if it's multiple upload field then set the object key as picture[0], picture[1]
            // otherwise just use picture
            const fileKey = `${inputKey}${
              files.length > 1 ? `[${index}]` : ""
            }`;
            // Convert Base64 to data URI
            // Assign it to your object
            myFiles[fileKey] = `data:${file.type};base64,${btoa(
              event.target.result
            )}`;

            resolve();
          };
          reader.onerror = function() {
            console.log("can't read the file");
            reject();
          };
        });
      });

      Promise.all(filePromises)
        .then(() => {
          isFilesReady = true;
          photoData = myFiles.picture;
          $('#nft_image_preview').attr('src', photoData);
        })
        .catch((error) => {
          console.log(error);
          console.log("something wrong happened");
        });
    });

    const formElement = document.getElementById("formcarryForm");

    function validateForm() {
      if (photoData != null) {
        return true;
      }
    }

    function mintNFT() {

    }

   function updateIPFSHash(hash) {
      // Show 'mint NFT'
      ipfsUrl = "https://gateway.pinata.cloud/ipfs/" + hash;
      console.log('IPFS upload:' + ipfsUrl)
      $("#ipfs_upload_json_url").attr('href', ipfsUrl).html("Verify Ipfs Upload");
      $('#nft_mint').prop('disabled', false);
      $('#nft_ipfs_upload').prop('disabled', true);
      $('#descriptionInput').prop('disabled', true);
      $('#passwordInput').prop('disabled', true);
      $('#pictureInput').prop('disabled', true);
      $('#nameInput').prop('disabled', true);

    }

    function submitFormToIPFS() {
      var self = this;
      console.log('submitting form');
      let data = {
        name: 'test nameInput',
        description: 'test desc',
        image: photoData
      };
      $.ajax({
        url : "https://api.pinata.cloud/pinning/pinJSONToIPFS",
        method: "POST",
        data: JSON.stringify(data),
        contentType : "application/json",
        headers : {
          // Dev Only, obfuscate when going to prod
          pinata_api_key: "bb8f09c99b53458ffb7b",
          pinata_secret_api_key: "26d0687df99869d7f5642176e545f4455529a2b52e8a1258ee3f32a76a4fbe75"
        },
        success : function(response, body, xhr) {
          /*
            {
                "IpfsHash": "QmTWtKPjcNk67dUeNPrCMsnsiDxV1kvuWh2uBQ2z5YsNx4",
                "PinSize": 58958,
                "Timestamp": "2021-11-11T19:22:55.071Z"
            }
          */
          updateIPFSHash(response.IpfsHash);
        },
        error : function(error) {
          alert('something went wrong during upload, please check the log');
          console.log(error);
        }
      });
    }
    const handleForm = async (event) => {
      event.preventDefault();

      if (!isFilesReady) {
        console.log("files still getting processed");
        return;
      }

      const formData = new FormData(formElement);

      let data = {
        name: formData.get("name"),
        message: formData.get("message")
      };

      Object.entries(myFiles).map((item) => {
        const [key, file] = item;
        // append the file to data object
        data[key] = file;
      });

      codeElem.textContent = JSON.stringify(data, undefined, 2);

    };


    // Click handler for form submission to IPFS
    $("#nft_ipfs_upload").click(function() {
      // Validate form
      validateForm();
      // Submit form data
      submitFormToIPFS();
    });

    $("#nft_mint").click(async function() {
      // Call to blockchain code and try and mint NFT with hashUrl
      console.log('minting');

      var web3 = new Web3(Web3.givenProvider || 'ws://some.local-or-remote.node:8546');
      const NSFWContract = new web3.eth.Contract(NFTContractABI, NFTContractAddress);

      // Document elements
      //let classPeriod = document.getElementById('addWalletToClass_ClassPeriod');
      let contractToBeApproved = "0x9c3C6ff39f65689ED820476362615a347bB23b3F";
      //if (classPeriod.value.length > 0 && walletId.value.length > 0) {
      if (contractToBeApproved.length > 0){

          // https://web3js.readthedocs.io/en/v1.2.11/web3-eth-contract.html#methods-mymethod-send


       // safeMintToThisContractWithApprovalToExternalContractUsingPassword(address approvalAddress, uint256 tokenId, string memory _password)
          await NSFWContract.methods.safeMintToThisContractWithApprovalToExternalContractUsingPassword(
            contractToBeApproved,
            "QmTWtKPjcNk67dUeNPrCMsnsiDxV1kvuWh2uBQ2z5YsNx4",
            "12345"
          )
          .send({from : Wolvercoin.currentAccount})
          .then(function(result, v1, v2) {
            console.log(result);
          });
        }
      });

    if (dev) {
      let hash = 'QmTWtKPjcNk67dUeNPrCMsnsiDxV1kvuWh2uBQ2z5YsNx4';
      updateIPFSHash(hash);
    }

    fetch("pages/nftABI.json").then(response =>
        response.json().then(data => ({
            data: data,
            status: response.status
        })
    ).then(res => {
      NFTContractABI = res.data;
      //  console.log(res.status, res.data.title)
    }));



  </script>
</div>
